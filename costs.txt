gasPrices.memory = 3
gasPrices.quadCoeffDiv = 512
gasPrices.sstoreNoopGasEIP2200 = 800
gasPrices.sstoreInitGasEIP2200 = 20000
gasPrices.sstoreClearRefundEIP2200 = 15000
gasPrices.sstoreCleanGasEIP2200 = 5000
gasPrices.sstoreClearRefundEIP2200 = 15000
gasPrices.sstoreClearRefundEIP2200 = 15000
gasPrices.sstoreInitRefundEIP2200 = 19200
gasPrices.sstoreCleanRefundEIP2200 = 4200
gasPrices.sstoreDirtyGasEIP2200 = 800
gasPrices.callValueTransfer = 9000
gasPrices.callNewAccount = 25000
gasPrices.expByte = 50
gasPrices.sha3Word = 6
gasPrices.copy = 3
gasPrices.logTopic = 375
gasPrices.logData = 8

subMemUsage(offset, length) {
  if (length.isZero()) return

  const words = (offset + length) / 32;
  if (words <= currentMemoryWordCount) return

  const fee = gasPrices.memory
  const quadCoeff = gasPrices.quadCoeffDiv
  const cost = words * fee + words * words / quadCoeff;

  if (cost > currentHighestMemCost)) {
    useGas(cost - currentHighestMemCost)
    currentHighestMemCost = cost
  }

  currentMemoryWordCount = words
}

updateSstoreGasEIP2200(
  currentStorage: Buffer,
  originalStorage: Buffer,
  value: Buffer,
) {
  // Noop
  if (currentStorage == value) {
    return useGas(gasPrices.sstoreNoopGasEIP2200);
  }
  if (originalStorage == currentStorage) {
    // Create slot
    if (originalStorage.length === 0) {
      return useGas(gasPrices.sstoreInitGasEIP2200);
    }
    // Delete slot
    if (value.length === 0) {
      refundGas(gasPrices.sstoreClearRefundEIP2200)
    }
    // Write existing slot
    return useGas(gasPrices.sstoreCleanGasEIP2200)
  }
  if (originalStorage.length > 0) {
    if (currentStorage.length === 0) {
      // Recreate slot
      subRefund(gasPrices.sstoreClearRefundEIP2200)
    } else if (value.length === 0) {
      // Delete slot
      refundGas(gasPrices.sstoreClearRefundEIP2200)
    }
  }
  if (originalStorage == value) {
    if (originalStorage.length === 0) {
      refundGas(gasPrices.sstoreInitRefundEIP2200)
    } else {
      refundGas(gasPrices.sstoreCleanRefundEIP2200)
    }
  }
  // Dirty update
  return useGas(gasPrices.sstoreDirtyGasEIP2200)
}

callCost(callType, inOffset, inLength, outOffset, outLength, value, toAddress) {
  const base = 700 + subMemUsage(inOffset, inLength) + subMemUsage(outOffset, outLength);

  if (callType == 'CALL' || callType == 'CALLCODE') {
    if (value != 0)
      base += gasPrices.callValueTransfer;
  }
  
  if (callType == 'CALL') {
    if (isAccountEmpty(toAddress) && value != 0)
      base += gasPrices.callNewAccount;
  }
}

NOTE:
1. SELFDESTRUCT -> chiamata esterna per verifica di presenza di un contratto o meno, pertanto unico costo assegnabile è quello base: 5000
2. CALL -> chiamata esterna per verifica di presenza di un contratto o meno, pertanto unico costo assegnabile è quello di CALLCODE
3. SSTORE -> PathGasMeter non tiene conto dei refund quindi il costo riportato non è quello reale anche perché potrebbe dipendere dall'input
4. 

Simple:
- STOP -> 0 ✓
- ADD -> 3 ✓
- MUL -> 5 ✓
- SUB -> 3 ✓
- DIV -> 5 ✓
- SDIV -> 5 ✓
- MOD -> 5 ✓
- SMOD -> 5 ✓
- ADDMOD -> 8 ✓
- MULMOD -> 8 ✓
- SIGNEXTEND -> 5 ✓
- LT -> 3 ✓
- GT -> 3 ✓
- SLT -> 3 ✓
- SGT -> 3 ✓
- EQ -> 3 ✓
- ISZERO -> 3 ✓
- AND -> 3 ✓
- OR -> 3 ✓
- XOR -> 3 ✓
- NOT -> 3 ✓
- BYTE -> 3 ✓
- SHL -> 3 ✓
- SHR -> 3 ✓
- SAR -> 3 ✓
- ADDRESS -> 2 ✓
- BALANCE -> 700 ✓
- ORIGIN -> 2 ✓
- CALLER -> 2 ✓
- CALLVALUE -> 2 ✓
- CALLDATALOAD -> 3 ✓
- CALLDATASIZE -> 2 ✓
- CODESIZE -> 2 ✓
- GASPRICE -> 2 ✓
- EXTCODESIZE -> 700 ✓
- RETURNDATASIZE -> 2 ✓
- EXTCODEHASH -> 700 ✓
- BLOCKHASH -> 20 ✓
- COINBASE -> 2 ✓
- TIMESTAMP -> 2 ✓
- NUMBER -> 2 ✓
- DIFFICULTY -> 2 ✓
- GASLIMIT -> 2 ✓
- CHAINID -> 2 ✓
- SELFBALANCE -> 5 ✓
- POP -> 2 ✓
- SLOAD -> 800 ✓
- JUMP -> 8 ✓
- JUMPI -> 10 ✓
- PC -> 2 ✓
- MSIZE -> 2 ✓
- GAS -> 2 ✓
- JUMPDEST -> 1 ✓
- PUSH1 -> 3 ✓
- PUSH2 -> 3 ✓
- PUSH3 -> 3 ✓
- PUSH4 -> 3 ✓
- PUSH5 -> 3 ✓
- PUSH6 -> 3 ✓
- PUSH7 -> 3 ✓
- PUSH8 -> 3 ✓
- PUSH9 -> 3 ✓
- PUSH10 -> 3 ✓
- PUSH11 -> 3 ✓
- PUSH12 -> 3 ✓
- PUSH13 -> 3 ✓
- PUSH14 -> 3 ✓
- PUSH15 -> 3 ✓
- PUSH16 -> 3 ✓
- PUSH17 -> 3 ✓
- PUSH18 -> 3 ✓
- PUSH19 -> 3 ✓
- PUSH20 -> 3 ✓
- PUSH21 -> 3 ✓
- PUSH22 -> 3 ✓
- PUSH23 -> 3 ✓
- PUSH24 -> 3 ✓
- PUSH25 -> 3 ✓
- PUSH26 -> 3 ✓
- PUSH27 -> 3 ✓
- PUSH28 -> 3 ✓
- PUSH29 -> 3 ✓
- PUSH30 -> 3 ✓
- PUSH31 -> 3 ✓
- PUSH32 -> 3 ✓
- DUP1 -> 3 ✓
- DUP2 -> 3 ✓
- DUP3 -> 3 ✓
- DUP4 -> 3 ✓
- DUP5 -> 3 ✓
- DUP6 -> 3 ✓
- DUP7 -> 3 ✓
- DUP8 -> 3 ✓
- DUP9 -> 3 ✓
- DUP10 -> 3 ✓
- DUP11 -> 3 ✓
- DUP12 -> 3 ✓
- DUP13 -> 3 ✓
- DUP14 -> 3 ✓
- DUP15 -> 3 ✓
- DUP16 -> 3 ✓
- SWAP1 -> 3 ✓
- SWAP2 -> 3 ✓
- SWAP3 -> 3 ✓
- SWAP4 -> 3 ✓
- SWAP5 -> 3 ✓
- SWAP6 -> 3 ✓
- SWAP7 -> 3 ✓
- SWAP8 -> 3 ✓
- SWAP9 -> 3 ✓
- SWAP10 -> 3 ✓
- SWAP11 -> 3 ✓
- SWAP12 -> 3 ✓
- SWAP13 -> 3 ✓
- SWAP14 -> 3 ✓
- SWAP15 -> 3 ✓
- SWAP16 -> 3 ✓
- INVALID -> 0
- SELFDESTRUCT -> 5000 [per nota 1]

Complex:
- EXP -> 10 + (exponent == 0 ? 0 : exponent.byteLength() * gasPrices.expByte)
- SHA3 -> 30 + subMemUsage(offset, length) + gasPrices.sha3Word * (length / 32)
- CALLDATACOPY -> 3 + subMemUsage(memOffset, dataLength) + gasPrices.copy * (dataLength == 0 ? 0 : dataLength / 32)
  1. dovrebbe dipendere dagli argomenti della chiamata
- CODECOPY -> 3  + subMemUsage(memOffset, dataLength) + gasPrices.copy * (dataLength == 0 ? 0 : dataLength / 32)
  1. non dipende dagli input alla chiamata
- EXTCODECOPY -> 700 + subMemUsage(memOffset, dataLength) + gasPrices.copy * (dataLength == 0 ? 0 : dataLength / 32)
  1. analogo a CODECOPY, ma bisogna conoscere il codice del contratto esterno perciò forse è impossibile
- RETURNDATACOPY -> 3 + subMemUsage(memOffset, dataLength) + gasPrices.copy * (dataLength == 0 ? 0 : dataLength / 32)
  1. non so cosa sia RETURNDATA, va approfondito sulla base di dove compare
- MLOAD -> 3 + subMemUsage(pos, 32)
  - (Maybe) CodeCopyMethod::copyRoutine@ConstantOptimiser.cpp
  - ArrayUtils::copyArrayToStorage@ArrayUtils.cpp
  - ArrayUtils::copyArrayToMemory@ArrayUtils.cpp
  - ArrayUtils::retrieveLength@ArrayUtils.cpp
  - CompilerUtils::fetchFreeMemoryPointer@CompilerUtils.cpp
  - CompilerUtils::abiDecode@CompilerUtils.cpp
  - CompilerUtils::loadFromMemoryHelper@CompilerUtils.cpp
  - ContractCompiler::appendFunctionSelector@ContractCompiler.cpp
  - ExpressionCompiler::visit(FunctionCall)@ExpressionCompiler.cpp
  - ExpressionCompiler::visit(MemberAccess)@ExpressionCompiler.cpp
  - ExpressionCompiler::appendExternalFunctionCall@ExpressionCompiler.cpp
  - MemoryItem::retrieveValue@LValue.cpp
- MSTORE -> 3 + subMemUsage(offset, 32) // 32 byte == 1 EVM word
  Si trova in:
    - AssignImmutable in Assembly::assemble@Assembly.cpp
    - ArrayUtils::copyArrayToMemory@ArrayUtils.cpp
    - CompilerUtils::storeFreeMemoryPointer@CompilerUtils.cpp
    - CompilerUtils::revertWithStringData@CompilerUtils.cpp
    - CompilerUtils::revertWithError@CompilerUtils.cpp
    - CompilerUtils::storeInMemory@CompilerUtils.cpp
    - CompilerUtils::storeInMemoryDynamic@CompilerUtils.cpp
    - CompilerUtils::encodeToMemory@CompilerUtils.cpp
    - ExpressionCompiler::visit(FunctionCall)@ExpressionCompiler.cpp
    - ExpressionCompiler::visit(MemberAccess)@ExpressionCompiler.cpp
    - ExpressionCompiler::appendExternalFunctionCall@ExpressionCompiler.cpp
    - MemoryItem::storeValue@LValue.cpp
- MSTORE8 -> 3 + subMemUsage(pos, 1) // 1 byte:
  Si trova in:
    - MemoryItem::storeValue@LValue.cpp
- SSTORE -> updateSstoreGasEIP2200(currentStorage, originalStorage, value)
- LOG0 -> 375 + subMemUsage(memOffset, memLength) + (gasPrices.logTopic * 0 + memLength * gasPrices.logData)
  1. vedere dove sono usati e quindi in che modo
- LOG1 -> 375 + subMemUsage(memOffset, memLength) + (gasPrices.logTopic * 1 + memLength * gasPrices.logData)
  1. vedere dove sono usati e quindi in che modo
- LOG2 -> 375 + subMemUsage(memOffset, memLength) + (gasPrices.logTopic * 2 + memLength * gasPrices.logData)
  1. vedere dove sono usati e quindi in che modo
- LOG3 -> 375 + subMemUsage(memOffset, memLength) + (gasPrices.logTopic * 3 + memLength * gasPrices.logData)
  1. vedere dove sono usati e quindi in che modo
- LOG4 -> 375 + subMemUsage(memOffset, memLength) + (gasPrices.logTopic * 4 + memLength * gasPrices.logData)
  1. vedere dove sono usati e quindi in che modo
- CREATE -> 32000 + subMemUsage(offset, length)
  1. bisogna conoscere la dimensione dell'altro contratto
- CREATE2 -> 32000 + subMemUsage(offset, length) + (gasPrices.sha3Word * (length / 32))
  1. bisogna conoscere la dimensione dell'altro contratto
- CALL -> callCost('CALLCODE', inOffset, inLength, outOffset, outLength, value, toAddr) [per nota 2]
- CALLCODE -> callCost('CALLCODE', inOffset, inLength, outOffset, outLength, value, toAddr)
- DELEGATECALL -> callCost('DELEGATECALL', inOffset, inLength, outOffset, outLength)
- STATICCALL -> callCost('STATICCALL', inOffset, inLength, outOffset, outLength)
- RETURN -> 0 + subMemUsage(offset, length)
- REVERT -> 0 + subMemUsage(offset, length)